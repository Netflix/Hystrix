/**
 * Copyright 2015 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.netflix.hystrix.contrib.codahalemetricspublisher;

import com.codahale.metrics.Gauge;
import com.codahale.metrics.MetricRegistry;
import com.netflix.hystrix.HystrixCircuitBreaker;
import com.netflix.hystrix.HystrixCommandGroupKey;
import com.netflix.hystrix.HystrixCommandKey;
import com.netflix.hystrix.HystrixCommandMetrics;
import com.netflix.hystrix.HystrixCommandProperties;
import com.netflix.hystrix.strategy.metrics.HystrixMetricsPublisherCommand;
import com.netflix.hystrix.util.HystrixRollingNumberEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rx.functions.Func0;

/**
 * Implementation of {@link HystrixMetricsPublisherCommand} using Coda Hale Metrics (https://github.com/codahale/metrics)
 */
public class HystrixCodaHaleMetricsPublisherCommand implements HystrixMetricsPublisherCommand {
    private final HystrixCommandKey key;
    private final HystrixCommandGroupKey commandGroupKey;
    private final HystrixCommandMetrics metrics;
    private final HystrixCircuitBreaker circuitBreaker;
    private final HystrixCommandProperties properties;
    private final MetricRegistry metricRegistry;
    private final String metricGroup;
    private final String metricType;

    static final Logger logger = LoggerFactory.getLogger(HystrixCodaHaleMetricsPublisherCommand.class);

    public HystrixCodaHaleMetricsPublisherCommand(HystrixCommandKey commandKey, HystrixCommandGroupKey commandGroupKey, HystrixCommandMetrics metrics, HystrixCircuitBreaker circuitBreaker, HystrixCommandProperties properties, MetricRegistry metricRegistry) {
        this.key = commandKey;
        this.commandGroupKey = commandGroupKey;
        this.metrics = metrics;
        this.circuitBreaker = circuitBreaker;
        this.properties = properties;
        this.metricRegistry = metricRegistry;
        this.metricGroup = commandGroupKey.name();
        this.metricType = key.name();
    }

    /**
     * An implementation note.  If there's a version mismatch between hystrix-core and hystrix-codahale-metrics-publisher,
     * the code below may reference a HystrixRollingNumberEvent that does not exist in hystrix-core.  If this happens,
     * a j.l.NoSuchFieldError occurs.  Since this data is not being generated by hystrix-core, it's safe to count it as 0
     * and we should log an error to get users to update their dependency set.
     */
    @Override
    public void initialize() {
        metricRegistry.register(createMetricName("isCircuitBreakerOpen"), (Gauge<Boolean>) circuitBreaker::isOpen);

        // allow monitor to know exactly at what point in time these stats are for so they can be plotted accurately
        metricRegistry.register(createMetricName("currentTime"), (Gauge<Long>) System::currentTimeMillis);

        // cumulative counts
        safelyCreateCumulativeCountForEvent("countBadRequests", () -> HystrixRollingNumberEvent.BAD_REQUEST);
        safelyCreateCumulativeCountForEvent("countCollapsedRequests", () -> HystrixRollingNumberEvent.COLLAPSED);
        safelyCreateCumulativeCountForEvent("countEmit", () -> HystrixRollingNumberEvent.EMIT);
        safelyCreateCumulativeCountForEvent("countExceptionsThrown", () -> HystrixRollingNumberEvent.EXCEPTION_THROWN);
        safelyCreateCumulativeCountForEvent("countFailure", () -> HystrixRollingNumberEvent.FAILURE);
        safelyCreateCumulativeCountForEvent("countFallbackEmit", () -> HystrixRollingNumberEvent.FALLBACK_EMIT);
        safelyCreateCumulativeCountForEvent("countFallbackFailure", () -> HystrixRollingNumberEvent.FALLBACK_FAILURE);
        safelyCreateCumulativeCountForEvent("countFallbackMissing", () -> HystrixRollingNumberEvent.FALLBACK_MISSING);
        safelyCreateCumulativeCountForEvent("countFallbackRejection", () -> HystrixRollingNumberEvent.FALLBACK_REJECTION);
        safelyCreateCumulativeCountForEvent("countFallbackSuccess", () -> HystrixRollingNumberEvent.FALLBACK_SUCCESS);
        safelyCreateCumulativeCountForEvent("countResponsesFromCache", () -> HystrixRollingNumberEvent.RESPONSE_FROM_CACHE);
        safelyCreateCumulativeCountForEvent("countSemaphoreRejected", () -> HystrixRollingNumberEvent.SEMAPHORE_REJECTED);
        safelyCreateCumulativeCountForEvent("countShortCircuited", () -> HystrixRollingNumberEvent.SHORT_CIRCUITED);
        safelyCreateCumulativeCountForEvent("countSuccess", () -> HystrixRollingNumberEvent.SUCCESS);
        safelyCreateCumulativeCountForEvent("countThreadPoolRejected", () -> HystrixRollingNumberEvent.THREAD_POOL_REJECTED);
        safelyCreateCumulativeCountForEvent("countTimeout", () -> HystrixRollingNumberEvent.TIMEOUT);

        // rolling counts
        safelyCreateRollingCountForEvent("rollingCountBadRequests", () -> HystrixRollingNumberEvent.BAD_REQUEST);
        safelyCreateRollingCountForEvent("rollingCountCollapsedRequests", () -> HystrixRollingNumberEvent.COLLAPSED);
        safelyCreateRollingCountForEvent("rollingCountEmit", () -> HystrixRollingNumberEvent.EMIT);
        safelyCreateRollingCountForEvent("rollingCountExceptionsThrown", () -> HystrixRollingNumberEvent.EXCEPTION_THROWN);
        safelyCreateRollingCountForEvent("rollingCountFailure", () -> HystrixRollingNumberEvent.FAILURE);
        safelyCreateRollingCountForEvent("rollingCountFallbackEmit", () -> HystrixRollingNumberEvent.FALLBACK_EMIT);
        safelyCreateRollingCountForEvent("rollingCountFallbackFailure", () -> HystrixRollingNumberEvent.FALLBACK_FAILURE);
        safelyCreateRollingCountForEvent("rollingCountFallbackMissing", () -> HystrixRollingNumberEvent.FALLBACK_MISSING);
        safelyCreateRollingCountForEvent("rollingCountFallbackRejection", () -> HystrixRollingNumberEvent.FALLBACK_REJECTION);
        safelyCreateRollingCountForEvent("rollingCountFallbackSuccess", () -> HystrixRollingNumberEvent.FALLBACK_SUCCESS);
        safelyCreateRollingCountForEvent("rollingCountResponsesFromCache", () -> HystrixRollingNumberEvent.RESPONSE_FROM_CACHE);
        safelyCreateRollingCountForEvent("rollingCountSemaphoreRejected", () -> HystrixRollingNumberEvent.SEMAPHORE_REJECTED);
        safelyCreateRollingCountForEvent("rollingCountShortCircuited", () -> HystrixRollingNumberEvent.SHORT_CIRCUITED);
        safelyCreateRollingCountForEvent("rollingCountSuccess", () -> HystrixRollingNumberEvent.SUCCESS);
        safelyCreateRollingCountForEvent("rollingCountThreadPoolRejected", () -> HystrixRollingNumberEvent.THREAD_POOL_REJECTED);
        safelyCreateRollingCountForEvent("rollingCountTimeout", () -> HystrixRollingNumberEvent.TIMEOUT);

        // the number of executionSemaphorePermits in use right now
        metricRegistry.register(createMetricName("executionSemaphorePermitsInUse"), (Gauge<Integer>) metrics::getCurrentConcurrentExecutionCount);

        // error percentage derived from current metrics
        metricRegistry.register(createMetricName("errorPercentage"), (Gauge<Integer>) () -> metrics.getHealthCounts().getErrorPercentage());

        // latency metrics
        metricRegistry.register(createMetricName("latencyExecute_mean"), (Gauge<Integer>) metrics::getExecutionTimeMean);
        metricRegistry.register(createMetricName("latencyExecute_percentile_5"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(5));
        metricRegistry.register(createMetricName("latencyExecute_percentile_25"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(25));
        metricRegistry.register(createMetricName("latencyExecute_percentile_50"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(50));
        metricRegistry.register(createMetricName("latencyExecute_percentile_75"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(75));
        metricRegistry.register(createMetricName("latencyExecute_percentile_90"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(90));
        metricRegistry.register(createMetricName("latencyExecute_percentile_99"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(99));
        metricRegistry.register(createMetricName("latencyExecute_percentile_995"), (Gauge<Integer>) () -> metrics.getExecutionTimePercentile(99.5));

        metricRegistry.register(createMetricName("latencyTotal_mean"), (Gauge<Integer>) metrics::getTotalTimeMean);
        metricRegistry.register(createMetricName("latencyTotal_percentile_5"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(5));
        metricRegistry.register(createMetricName("latencyTotal_percentile_25"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(25));
        metricRegistry.register(createMetricName("latencyTotal_percentile_50"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(50));
        metricRegistry.register(createMetricName("latencyTotal_percentile_75"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(75));
        metricRegistry.register(createMetricName("latencyTotal_percentile_90"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(90));
        metricRegistry.register(createMetricName("latencyTotal_percentile_99"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(99));
        metricRegistry.register(createMetricName("latencyTotal_percentile_995"), (Gauge<Integer>) () -> metrics.getTotalTimePercentile(99.5));

        // group
        metricRegistry.register(createMetricName("commandGroup"), (Gauge<String>) () -> commandGroupKey != null ? commandGroupKey.name() : null);

        // properties (so the values can be inspected and monitored)
        metricRegistry.register(createMetricName("propertyValue_rollingStatisticalWindowInMilliseconds"), (Gauge<Number>) () -> properties.metricsRollingStatisticalWindowInMilliseconds().get());
        metricRegistry.register(createMetricName("propertyValue_circuitBreakerRequestVolumeThreshold"), (Gauge<Number>) () -> properties.circuitBreakerRequestVolumeThreshold().get());
        metricRegistry.register(createMetricName("propertyValue_circuitBreakerSleepWindowInMilliseconds"), (Gauge<Number>) () -> properties.circuitBreakerSleepWindowInMilliseconds().get());
        metricRegistry.register(createMetricName("propertyValue_circuitBreakerErrorThresholdPercentage"), (Gauge<Number>) () -> properties.circuitBreakerErrorThresholdPercentage().get());
        metricRegistry.register(createMetricName("propertyValue_circuitBreakerForceOpen"), (Gauge<Boolean>) () -> properties.circuitBreakerForceOpen().get());
        metricRegistry.register(createMetricName("propertyValue_circuitBreakerForceClosed"), (Gauge<Boolean>) () -> properties.circuitBreakerForceClosed().get());
        metricRegistry.register(createMetricName("propertyValue_executionIsolationThreadTimeoutInMilliseconds"), (Gauge<Number>) () -> properties.executionTimeoutInMilliseconds().get());
        metricRegistry.register(createMetricName("propertyValue_executionTimeoutInMilliseconds"), (Gauge<Number>) () -> properties.executionTimeoutInMilliseconds().get());
        metricRegistry.register(createMetricName("propertyValue_executionIsolationStrategy"), (Gauge<String>) () -> properties.executionIsolationStrategy().get().name());
        metricRegistry.register(createMetricName("propertyValue_metricsRollingPercentileEnabled"), (Gauge<Boolean>) () -> properties.metricsRollingPercentileEnabled().get());
        metricRegistry.register(createMetricName("propertyValue_requestCacheEnabled"), (Gauge<Boolean>) () -> properties.requestCacheEnabled().get());
        metricRegistry.register(createMetricName("propertyValue_requestLogEnabled"), (Gauge<Boolean>) () -> properties.requestLogEnabled().get());
        metricRegistry.register(createMetricName("propertyValue_executionIsolationSemaphoreMaxConcurrentRequests"), (Gauge<Number>) () -> properties.executionIsolationSemaphoreMaxConcurrentRequests().get());
        metricRegistry.register(createMetricName("propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests"), (Gauge<Number>) () -> properties.fallbackIsolationSemaphoreMaxConcurrentRequests().get());
    }

    protected String createMetricName(String name) {
        return MetricRegistry.name(metricGroup, metricType, name);
    }

    protected void createCumulativeCountForEvent(final String name, final HystrixRollingNumberEvent event) {
        metricRegistry.register(createMetricName(name), (Gauge<Long>) () -> metrics.getCumulativeCount(event));
    }

    protected void safelyCreateCumulativeCountForEvent(final String name, final Func0<HystrixRollingNumberEvent> eventThunk) {
        metricRegistry.register(createMetricName(name), (Gauge<Long>) () -> {
            try {
                return metrics.getCumulativeCount(eventThunk.call());
            } catch (NoSuchFieldError error) {
                logger.error("While publishing CodaHale metrics, error looking up eventType for : " + name + ".  Please check that all Hystrix versions are the same!");
                return 0L;
            }
        });
    }

    protected void createRollingCountForEvent(final String name, final HystrixRollingNumberEvent event) {
        metricRegistry.register(createMetricName(name), (Gauge<Long>) () -> metrics.getRollingCount(event));
    }

    protected void safelyCreateRollingCountForEvent(final String name, final Func0<HystrixRollingNumberEvent> eventThunk) {
        metricRegistry.register(createMetricName(name), (Gauge<Long>) () -> {
            try {
                return metrics.getRollingCount(eventThunk.call());
            } catch (NoSuchFieldError error) {
                logger.error("While publishing CodaHale metrics, error looking up eventType for : " + name + ".  Please check that all Hystrix versions are the same!");
                return 0L;
            }
        });
    }
}
